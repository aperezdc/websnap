#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright Â© 2013 Adrian Perez <aperez@igalia.com>
#
# Distributed under terms of the MIT license.

from os import path, listdir


def file_contents(*arg, default=None):
    fullpath = path.join(*arg)
    if path.isfile(fullpath):
        with open(fullpath) as fd:
            return fd.read()
    else:
        return default


class RunData(object):
    def __init__(self, url, timing, actual_url=None, exitcode=0, repeat=1):
        self.url = str(url).strip()
        self.timing = None if timing is None else float(timing)
        self.actual_url = self.url if actual_url is None else str(actual_url).strip()
        self.exitcode = int(exitcode)
        self.repeat = int(repeat)

    def __repr__(self):
        return "{}('{}')".format(self.__class__.__name__, self.url)

    @property
    def valid(self):
        return self.timing is not None

    @staticmethod
    def from_data_dir(dirpath):
        # NOTE: Stdout lines have: <URL> <repeat> <time-in-seconds>
        exitcode = int(file_contents(dirpath, "exitcode", default=0))
        repeat   = int(file_contents(dirpath, "repeat",   default=1))
        url      = file_contents(dirpath, "url")
        stdout   = file_contents(dirpath, "stdout")

        if stdout is not None:
            stdout = stdout.strip().split()
        else:
            stdout = (url, repeat, None)
        assert repeat == int(stdout[1])

        return RunData(url        = url,
                       actual_url = stdout[0],
                       repeat     = repeat,
                       timing     = stdout[2],
                       exitcode   = exitcode)


def load_data_dir(dirpath):
    """Iterates over a directory yielding :class:`RunData` items.
    """
    if not path.isdir(dirpath):
        raise ValueError("Path '{}' is not a directory".format(dirpath))

    for subdir in listdir(dirpath):
        subdirpath = path.join(dirpath, subdir)
        if path.isdir(subdirpath):
            yield RunData.from_data_dir(subdirpath)


def merge_data(dir1, dir2):
    dir1data = dict(((d.url, d) for d in load_data_dir(dir1)))
    dir2data = dict(((d.url, d) for d in load_data_dir(dir2)))

    urlset = set(dir1data.keys())
    urlset.intersection_update(frozenset(dir2data.keys()))

    for url in urlset:
        data1 = dir1data[url]
        data2 = dir2data[url]
        if not (data1.valid and data2.valid):
            continue
        assert data1.url == data2.url == url
        assert data1.actual_url == data2.actual_url
        print(",".join(map(str, (data1.url,
                                 data1.repeat,
                                 data1.timing,
                                 data2.timing,
                                 data1.timing / data1.repeat,
                                 data2.timing / data2.repeat))))



if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        raise SystemExit("Usage: {} datadir1 datadir2 [> combined.csv]\n"
                         "\n"
                         "  datadir1, datadir2\n"
                         "     Data directories as generated by the 'runtests'\n"
                         "     script included with 'websnap'\n"
                         "\n"
                         "The output is a file with comma-separated values (CSV)\n"
                         "which contains the following columns:\n"
                         "\n"
                         "  URL\n"
                         "  Number renderings done\n"
                         "  Timing from datadir1\n"
                         "  Timing from datadir2\n"
                         "  Timing per render from datadir1\n"
                         "  Timing per render from datadir2\n".format(sys.argv[0]))
    merge_data(*sys.argv[1:3])


